// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// This file generates data.gen.go.
// It embeds the text of all the licenses in the subdirectory "licenses"
// and constructs the data structures to represent them.
// Run by a "go:generate" comment in license.go.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"
)

var outFile = flag.String("o", "data.gen.go", "`file` to write")

func main() {
	log.SetFlags(0)
	log.SetPrefix("gen: ")
	flag.Parse()

	files, err := filepath.Glob(filepath.Join("licenses", "*"))
	if err != nil {
		log.Fatal(err)
	}
	if len(files) == 0 {
		log.Fatal("no license files")
	}

	out := new(bytes.Buffer)

	fmt.Fprint(out, topOfFile)

	fmt.Fprintf(out, "func init() {\n")
	fmt.Fprintf(out, "\tfiles := []License{\n")
	for _, file := range files {
		fmt.Fprintf(out, "\t\t{Name: %q, Text: %v},\n", filepath.Base(file), varName(file))
	}
	fmt.Fprintf(out, "\t}\n")
	fmt.Fprintf(out, "\tbuiltin = New(append(files, builtinURLs...))\n")
	fmt.Fprintf(out, "}\n")

	const (
		backQ = '`'
		Q     = '"'
	)

	for _, file := range files {
		data, err := ioutil.ReadFile(file)
		if err != nil {
			log.Fatal(err)
		}
		fmt.Fprintf(out, "const %s = ", varName(file))
		// We assume there's no initial or terminal `. It doesn't matter. In fact,
		// We could ignore ` altogether if we wanted since normalize strips
		// them anyway. But why not preserve the original, and the code is fun.
		for i, blob := range bytes.Split(data, []byte{backQ}) {
			if i > 0 {
				fmt.Fprintf(out, "%c + %c%c%c + ", backQ, Q, backQ, Q)
			}
			fmt.Fprintf(out, "`%s", blob)
		}
		fmt.Fprintf(out, "`\n")
	}

	src, err := format.Source(out.Bytes())
	if err != nil {
		fd, err1 := ioutil.TempFile("", "license-data")
		if err1 == nil {
			_, err1 = fd.Write(out.Bytes())
			if err1 == nil {
				log.Fatalf("parsing output (written to %s): %v", fd.Name(), err)
			}
			fd.Close()
		}
		log.Fatal("parsing output:", err)
	}
	err = ioutil.WriteFile(*outFile, src, 0644)
	if err != nil {
		log.Fatal(err)
	}
}

// varName returns the basename of the file, sanitized for use as a variable name,
// and given the prefix "license_".
func varName(file string) string {
	var out strings.Builder
	out.WriteString("license_")
	for _, c := range filepath.Base(file) {
		switch {
		case c == '-', c == '.':
			c = '_'
		case 'a' <= c && c <= 'z':
		case 'A' <= c && c <= 'Z':
		case '0' <= c && c <= '9':
		case c == '_':
		}
		out.WriteRune(c)
	}
	return out.String()
}

const topOfFile = `
// Code generated by gen_data.go; DO NOT EDIT.

package licensecheck
`
